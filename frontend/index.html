<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
  <title>AR Measure</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: system-ui, sans-serif; 
      background: #000; 
      color: #fff; 
      overflow: hidden; 
      height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 20px;
      position: relative;
    }
    #arButton {
      background: linear-gradient(135deg, #00bfff, #1e3a8a);
      color: #fff; 
      border: none; 
      padding: 20px 40px;
      border-radius: 50px; 
      font-size: 24px; 
      font-weight: 600;
      cursor: pointer; 
      box-shadow: 0 0 20px rgba(0, 191, 255, 0.5), 0 10px 30px rgba(30, 58, 138, 0.3);
      transition: all 0.3s ease;
      animation: bluePulse 2s infinite;
      display: block !important;
      position: relative; z-index: 10;
    }
    #arButton:hover, #arButton:active { 
      transform: translateY(-2px); 
      box-shadow: 0 0 30px rgba(0, 191, 255, 0.7), 0 15px 40px rgba(30, 58, 138, 0.4); 
    }
    @keyframes bluePulse {
      0%, 100% { box-shadow: 0 0 20px rgba(0, 191, 255, 0.5), 0 10px 30px rgba(30, 58, 138, 0.3); }
      50% { box-shadow: 0 0 30px rgba(0, 191, 255, 0.8), 0 15px 40px rgba(30, 58, 138, 0.5); }
    }
    #info {
      text-align: center;
      font-size: 18px;
      opacity: 0.8;
      max-width: 300px;
      padding: 0 20px;
      position: relative; z-index: 10;
    }
    #stopButton {
      background: linear-gradient(135deg, #ff3b30, #ff6b6b);
      color: #fff; 
      border: none; 
      padding: 15px 30px;
      border-radius: 50px; 
      font-size: 18px; 
      font-weight: 600;
      cursor: pointer; 
      box-shadow: 0 10px 30px rgba(255, 59, 48, 0.3);
      transition: all 0.3s ease;
      display: none;
      position: absolute; top: 20px; right: 20px; z-index: 10; /* Position top-right for visibility */
    }
    #stopButton:hover { transform: translateY(-2px); box-shadow: 0 15px 40px rgba(255, 59, 48, 0.4); }
    .ar-active #arButton { display: none !important; }
    .ar-active #stopButton { display: block; }
    .ar-active #info { 
      opacity: 1; 
      position: absolute; 
      top: 70px; /* Below stop button */
      left: 20px; 
      right: 20px; 
      background: rgba(0,0,0,0.7); 
      padding: 10px; 
      border-radius: 10px; 
      text-align: center;
    }
    .measurement-active #videoFeed, .measurement-active #overlay { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    }
    .measurement-active #arButton, .measurement-active #info { display: none; }
    .measurement-active #resetBtn { display: block; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); }
    @media (max-width: 480px) {
      #arButton { font-size: 20px; padding: 18px 30px; min-height: 60px; }
      #info { font-size: 16px; }
    }
  </style>
</head>
<body>
  <button id="arButton">Start AR</button>
  <div id="info">Detecting AR support...</div>
  <button id="stopButton">Stop AR</button>
  <button id="resetBtn" style="display: none;">Reset</button>

  <video id="videoFeed" style="display: none;" autoplay playsinline></video>
  <canvas id="overlay" style="display: none;"></canvas>

  <script>
    console.log("Script loaded on OnePlus");
    const info = document.getElementById("info");
    const arButton = document.getElementById("arButton");
    const stopButton = document.getElementById("stopButton");
    const resetBtn = document.getElementById("resetBtn");
    const videoFeed = document.getElementById("videoFeed");
    const overlay = document.getElementById("overlay");

    arButton.style.display = "block";

    async function supportsWebXR() {
      if (!window.THREE || !navigator.xr) return false;
      try {
        return await navigator.xr.isSessionSupported("immersive-ar");
      } catch (e) {
        console.warn("WebXR support check:", e);
        return false;
      }
    }

    let scene, camera, renderer, reticle, hitTestSource, session;
    let points = [], lines = [];
    let frameCount = 0, textureCheck = 0, fallbackTimeout;

    function initAR() {
      if (typeof THREE === "undefined") {
        info.textContent = "Error loading 3D library—retry";
        return;
      }
      scene = new THREE.Scene();
      scene.background = null;
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      const ringGeom = new THREE.RingGeometry(0.015, 0.025, 32);
      ringGeom.rotateX(-Math.PI / 2);
      reticle = new THREE.Mesh(ringGeom, new THREE.MeshBasicMaterial({ color: 0x00bfff }));
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      console.log("AR initialized");
    }

    async function startAR() {
      if (session) return;
      arButton.disabled = true;
      info.textContent = "Starting AR—move slowly to scan...";
      document.body.classList.add("ar-active");
      frameCount = 0; textureCheck = 0;

      try {
        session = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ["hit-test"],
          optionalFeatures: ["dom-overlay"],
          domOverlay: { root: document.body }
        });
        renderer.xr.setSession(session);
        session.addEventListener("select", onSelect);
        session.addEventListener("end", onSessionEnd);

        const viewerSpace = await session.requestReferenceSpace("viewer");
        const localSpace = await session.requestReferenceSpace("local"); // Added for better pose
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

        info.textContent = "Point at surface—tap blue ring to measure";
        console.log("AR session active on OnePlus");
        renderer.setAnimationLoop(animate);
        fallbackTimeout = setTimeout(checkFallback, 1500); // Faster detect
      } catch (e) {
        console.warn("AR launch error:", e);
        info.textContent = "AR failed—switching to camera";
        startFallback();
      }
      arButton.disabled = false;
    }

    function onSelect() {
      if (reticle.visible) {
        const pos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
        placePoint(pos);
      }
    }

    function animate(time, frame) {
      frameCount++;
      if (!frame || !session || !hitTestSource) return;

      // Enhanced texture check: Log if no baseLayer
      if (session.renderState.baseLayer && !textureCheck) {
        textureCheck = 1; // Flag success
        console.log("Video texture bound");
      }

      const hitTestResults = frame.getHitTestResults(hitTestSource);
      if (hitTestResults.length) {
        const pose = hitTestResults[0].getPose(renderer.xr.getReferenceSpace() || localSpace);
        if (pose) {
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
          if (fallbackTimeout) clearTimeout(fallbackTimeout);
        }
      } else {
        reticle.visible = false;
      }
      renderer.render(scene, camera);
    }

    function placePoint(pos) {
      const dot = new THREE.Mesh(
        new THREE.SphereGeometry(0.01, 32, 16),
        new THREE.MeshBasicMaterial({ color: 0x00ff88 })
      );
      dot.position.copy(pos);
      scene.add(dot);
      points.push(dot);

      lines.forEach(l => scene.remove(l));
      lines = [];
      for (let i = 1; i < points.length; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([points[i-1].position, points[i].position]);
        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 6 }));
        scene.add(line);
        lines.push(line);
      }
      updateInfo();
    }

    function updateInfo() {
      if (points.length < 2) {
        info.textContent = points.length ? "1 point—tap another" : "Tap ring to place first point";
        return;
      }
      let total = 0, last = 0;
      for (let i = 1; i < points.length; i++) {
        const d = points[i].position.distanceTo(points[i-1].position);
        total += d;
        if (i === points.length - 1) last = d;
      }
      info.innerHTML = `${points.length} points<br>Total: ${total.toFixed(2)}m | Last: ${last.toFixed(2)}m`;
    }

    function onSessionEnd() {
      session = null;
      hitTestSource?.release();
      document.body.classList.remove("ar-active");
      if (fallbackTimeout) clearTimeout(fallbackTimeout);
      info.textContent = "AR stopped—tap Start to retry";
      resetAll();
      renderer.setAnimationLoop(null);
    }

    function resetAll() {
      points.forEach(p => scene.remove(p));
      lines.forEach(l => scene.remove(l));
      points = []; lines = [];
      updateInfo();
    }

    function checkFallback() {
      if (frameCount < 20 || !textureCheck) { // Stricter: <20 frames or no texture
        console.warn("Black screen detected—fallback to 2D on OnePlus");
        session?.end();
        startFallback();
      }
    }

    async function startFallback() {
      document.body.classList.add("measurement-active");
      resetBtn.style.display = "block";
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 } }
        });
        videoFeed.srcObject = stream;
        videoFeed.play();
        videoFeed.onloadedmetadata = () => {
          overlay.width = videoFeed.videoWidth;
          overlay.height = videoFeed.videoHeight;
          overlay.style.pointerEvents = "auto";
          videoFeed.style.display = "block";
          info.textContent = "Camera active (2D mode)—tap to place points";
          draw2D();
        };
      } catch (err) {
        info.textContent = "Camera denied—check permissions";
        console.error("Fallback camera error:", err);
      }
    }

    let points2D = [];
    const ctx = overlay.getContext("2d");

    function onTap2D(e) {
      e.preventDefault();
      const rect = overlay.getBoundingClientRect();
      const x = (e.touches?.[0]?.clientX || e.clientX) - rect.left;
      const y = (e.touches?.[0]?.clientY || e.clientY) - rect.top;
      const scaleX = overlay.width / rect.width;
      const scaleY = overlay.height / rect.height;
      points2D.push({ x: x * scaleX, y: y * scaleY });
      draw2D();
    }

    function draw2D() {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      points2D.forEach(p => {
        ctx.fillStyle = "lime";
        ctx.beginPath();
        ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
        ctx.fill();
      });
      if (points2D.length > 1) {
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(points2D[0].x, points2D[0].y);
        for (let i = 1; i < points2D.length; i++) {
          ctx.lineTo(points2D[i].x, points2D[i].y);
        }
        ctx.stroke();
      }
      let total = 0;
      for (let i = 1; i < points2D.length; i++) {
        const dx = points2D[i].x - points2D[i-1].x;
        const dy = points2D[i].y - points2D[i-1].y;
        total += Math.hypot(dx, dy) * 0.0011; // Adjust for OnePlus camera
      }
      info.textContent = points2D.length < 2 
        ? `Points: ${points2D.length} — Tap to add`
        : `Distance: ${total.toFixed(3)} m (${points2D.length} pts)`;
    }

    overlay.addEventListener("touchstart", onTap2D, { passive: false });
    overlay.addEventListener("click", onTap2D);
    resetBtn.onclick = () => { points2D = []; draw2D(); info.textContent = "Reset—tap to measure"; };

    (async () => {
      console.log("OnePlus detection...");
      info.textContent = "Checking AR...";
      const xrSupported = await supportsWebXR();
      arButton.disabled = false;
      if (xrSupported) {
        info.textContent = "AR ready—tap to start measuring";
        arButton.textContent = "Start AR";
        initAR();
        arButton.onclick = startAR;
      } else {
        info.textContent = "AR unavailable—using camera mode";
        arButton.textContent = "Start Camera Measure";
        arButton.onclick = startFallback;
      }
      stopButton.onclick = () => session?.end();
    })();
  </script>
</body>
</html>
